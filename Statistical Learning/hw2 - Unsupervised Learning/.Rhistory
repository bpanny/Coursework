# CH index
CH <- NbClust(data=arrest, min.nc = 2, max.nc = 6,
method="kmeans", index="ch")
plot(2:6, CH$All.index, type="o",
xlab="number of clusters", ylab="CH index",
"cex.lab"=1.5, cex=2.5)
CH$Best.nc[1]
# CH$Best.partition  #we can also get Partition that
#### corresponds to the best number of clusters
# Hartigan index
H <- NbClust(data=arrest, min.nc = 2, max.nc = 6,
method="kmeans", index="hartigan")
plot(2:6, H$All.index, type="o",
xlab="number of clusters",ylab="Hartigan index",
"cex.lab"=1.5, cex=2.5)
abline(h=10,lty=2,lwd=3) # stop when H(k) < 10
H$Best.nc[1]
# KL index
KL <- NbClust(data=arrest, min.nc = 2, max.nc = 6,
method="kmeans",index="kl")
plot(2:6, KL$All.index, type="o",
xlab="number of clusters",ylab="KL index",
"cex.lab"=1.5, cex=2.5)
KL$Best.nc[1]
# Silhouette index
Sil <- NbClust(data=arrest, min.nc = 2, max.nc = 6,
method="kmeans", index="silhouette")
plot(2:6, Sil$All.index, type="o",
xlab="number of clusters",ylab="Silhouette index",
"cex.lab"=1.5, cex=2.5)
Sil$Best.nc[1]
library(cluster)
gapst <- clusGap(arrest, FUN = kmeans, nstart = 100,
K.max = 6, B = 50,
spaceH0 ="scaledPCA")
plot(gapst, xlab = "number of cluster k", main = "Gap statistics")
gaprs <- with(gapst,
maxSE(Tab[,"gap"],Tab[,"SE.sim"]))
gaprs
# gaprs <- maxSE(gapst$Tab[,"gap"],gapst$Tab[,"SE.sim"])
# print(gaprs, method = "firstmax")
# Observations are represented by points in the plot, using principal components
km <- kmeans(arrest, centers = 3, nstart=10)
km_label <- km$cluster
km_vis <- fviz_cluster(list(data = arrest, cluster = km_label),
ellipse.type = "convex",
geom = c("point","text"),
labelsize = 5,
palette = "Dark2") + labs(title = "K-means")
km_vis
# distance between patients
row_distance = dist(arrest, method = "euclidean")
# try different linkage
hc.complete <- hclust(d = row_distance, method = "complete")
plot(hc.complete)
hc_label<-cutree(hc.complete, k = 3)
# hc_label<-cutree(hc.complete, k = 3)
# hc_label<-cutree(hc.average, k = 3)
# hc_label<-cutree(hc.single, k = 3)
# hc_label<-cutree(hc.centroid, k = 3)
hc_label
table(hc_label,km_label)
library(mclust) # Adjusted Rand Index
adjustedRandIndex(hc_label, label)
fviz_dend(hc.complete,
k = 3,
cex = 0.3,
palette = "jco",
color_labels_by_k = TRUE,
rect = TRUE,
rect_fill = TRUE,
rect_border = "jco",
labels_track_height = 3.5)
state_pairs <- expand.grid(names(hc_label),names(hc_label))
state_pairs <- tibble(state_pairs[-which(state_pairs[,1]==state_pairs[,2]),]) %>%
rename(state1 = Var1, state2 = Var2)
clusts <- tibble(state1 = names(hc_label), hc = hc_label, km = km$cluster)
full <- clusts %>%
full_join(state_pairs, by = 'state1') %>%
left_join(clusts %>% rename(state2 = state1), by = c('state2'))
full_eval <- full %>%
mutate(together_idx = (hc.x==km.x & hc.y==km.y),
separate_idx = (hc.x!=km.x & hc.y!=km.y),
discord_idx = (!(together_idx | separate_idx)))
rand_idx <- (sum(full_eval$together_idx) + sum(full_eval$separate_idx)) / nrow(full_eval)
rand_idx
arrest_scaled <- arrest %>%
mutate(across(everything(), scale))
# distance between patients
row_distance_scaled = dist(arrest_scaled, method = "euclidean")
hc.complete_scaled <- hclust(d = row_distance_scaled, method = "complete")
plot(hc.complete_scaled)
for (i in tibble(x = 1:2)){print(i)}
for (i in data.frame(x = 1:2)){print(i)}
for (i in data.frame(x = 1:2, y = 3:4)){print(i)}
for (i in data.frame(x = 1:2, y = 3:4)){print(i[2])}
q2
for (i in q2){print(i)}
q2
knitr::opts_chunk$set(echo = TRUE)
q2 %>% group_by(cluster) %>% summarise(centroids = mean())
library(tidyverse)
library(tidyverse)
q2 %>% group_by(cluster) %>% summarise(centroids = mean())
q2 %>% group_by(cluster) %>% summarise(centroids = mean(x1))
q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, size = 10, shape = factor(cluster), color = factor(cluster))) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids, shape = factor(cluster), color=factor(cluster)))
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, size = 10, shape = factor(cluster), color = factor(cluster))) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids, shape = 'square', color=factor(cluster)))
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, size = 10, shape = factor(cluster), color = factor(cluster))) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids, shape = 'square', color=factor(cluster)), alpha = .5)
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, size = 10, shape = factor(cluster), color = factor(cluster))) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids, shape = 'square', alpha = .5)
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, size = 10, shape = factor(cluster), color = factor(cluster))) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids, shape = 'square'), alpha = .5)
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, size = 10, shape = factor(cluster), color = factor(cluster))) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids, shape = 'square'),inherit.aes=F, alpha = .5)
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, size = 10, shape = factor(cluster), color = factor(cluster))) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids, shape = 'square', size = 7, color='green'),inherit.aes=F, alpha = .5)
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, size = 10, shape = factor(cluster), color = factor(cluster))) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids, shape = 'square', size = 7),color='green',inherit.aes=F, alpha = .5)
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, size = 10, shape = factor(cluster), color = factor(cluster))) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids),shape = 'square', size = 7,color='green',inherit.aes=F, alpha = .5)
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, size = 10, shape = factor(cluster), color = factor(cluster))) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids),shape = 'square', size = 5,color='green',inherit.aes=F, alpha = .5)
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, shape = factor(cluster), color = factor(cluster)),size = 10) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids),shape = 'square', size = 5,color='green',inherit.aes=F, alpha = .5)
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, shape = factor(cluster), color = factor(cluster)),size = 109) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids),shape = 'square', size = 5,color='green',inherit.aes=F, alpha = .5)
?geom_point
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, shape = factor(cluster), color = factor(cluster))) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids),shape = 'square', size = 5,color='green',inherit.aes=F, alpha = .5)
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, shape = factor(cluster), color = factor(cluster)), size = 10) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids),shape = 'square', size = 5,color='green',inherit.aes=F, alpha = .5)
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, shape = factor(cluster), color = factor(cluster), size = 10)) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids),shape = 'square', size = 5,color='green',inherit.aes=F, alpha = .5)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
q2 <- tibble(x1 = c(1,1,0,5,6,4), x2 = c(4,3,4,1,2,0))
q2 %>% ggplot(aes(x = x1, y = x2)) + geom_point()
q2$initial_cluster <- sample(1:2, size = nrow(q2), replace = T, prob = c(.5,.5))
q2$cluster <- q2$initial_cluster
while(TRUE) {
means <- q2 %>% group_by(cluster) %>% summarise(mean1 = mean(x1), mean2 = mean(x2))
for (i in 1:nrow(q2)) {
row <- q2[i, c('x1', 'x2')]
distances <- (means$mean1 - row$x1)^2 + (means$mean2 - row$x2)^2
q2$cluster[i] <- which.min(distances)
}
new_means <- q2 %>% group_by(cluster) %>% summarise(mean1 = mean(x1), mean2 = mean(x2))
if (all(means$mean1 == new_means$mean1) && all(means$mean2 == new_means$mean2)) {
break
}
}
q2
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, shape = factor(cluster), color = factor(cluster), size = 10)) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids),shape = 'square', size = 5,color='green',inherit.aes=F, alpha = .5)
library(ISLR)
arrest <- USArrests
pca <- prcomp(arrest, center = TRUE, scale. = TRUE)
# matrix of variable loadings
# head(pca$rotation)
dim(pca$rotation)
# PCA demension 1
pca1 <- pca$x[,1]
# PCA demension 2
pca2 <- pca$x[,2]
pctbl <- tibble(pc1 = pca1, pc2 = pca2, state = rownames(arrest))
pctbl %>% ggplot(aes(x = pc1, y = pc2, label = state)) + geom_text()
library(factoextra)
fviz_eig(pca, addlabels = TRUE)
fviz_pca_ind(pca,
label = "none",
addEllipses = TRUE)
# within-cluster sum of squares
WCSS<-rep(0,5)
# choose k:
for(k in 1:6){
# Perform k-means clustering on a data matrix.
res<-kmeans(x = arrest, centers = k, nstart = 100)
# Total within-cluster sum of squares
WCSS[k]<-res$tot.withinss
}
#plot WCSS vs different K values
plot(1:6, WCSS,
type="o", col="black",
xlab="K", ylab="WCSS")
title("WCSS for three-clusters data")
points(3, WCSS[3], col="red",cex=2,pch=20)
library(NbClust)
# We can use NbClust package to calculate the four indices
# CH index
CH <- NbClust(data=arrest, min.nc = 2, max.nc = 6,
method="kmeans", index="ch")
plot(2:6, CH$All.index, type="o",
xlab="number of clusters", ylab="CH index",
"cex.lab"=1.5, cex=2.5)
CH$Best.nc[1]
# CH$Best.partition  #we can also get Partition that
#### corresponds to the best number of clusters
# Hartigan index
H <- NbClust(data=arrest, min.nc = 2, max.nc = 6,
method="kmeans", index="hartigan")
plot(2:6, H$All.index, type="o",
xlab="number of clusters",ylab="Hartigan index",
"cex.lab"=1.5, cex=2.5)
abline(h=10,lty=2,lwd=3) # stop when H(k) < 10
H$Best.nc[1]
# KL index
KL <- NbClust(data=arrest, min.nc = 2, max.nc = 6,
method="kmeans",index="kl")
plot(2:6, KL$All.index, type="o",
xlab="number of clusters",ylab="KL index",
"cex.lab"=1.5, cex=2.5)
KL$Best.nc[1]
# Silhouette index
Sil <- NbClust(data=arrest, min.nc = 2, max.nc = 6,
method="kmeans", index="silhouette")
plot(2:6, Sil$All.index, type="o",
xlab="number of clusters",ylab="Silhouette index",
"cex.lab"=1.5, cex=2.5)
Sil$Best.nc[1]
library(cluster)
gapst <- clusGap(arrest, FUN = kmeans, nstart = 100,
K.max = 6, B = 50,
spaceH0 ="scaledPCA")
plot(gapst, xlab = "number of cluster k", main = "Gap statistics")
gaprs <- with(gapst,
maxSE(Tab[,"gap"],Tab[,"SE.sim"]))
gaprs
# gaprs <- maxSE(gapst$Tab[,"gap"],gapst$Tab[,"SE.sim"])
# print(gaprs, method = "firstmax")
# Observations are represented by points in the plot, using principal components
km <- kmeans(arrest, centers = 3, nstart=10)
km_label <- km$cluster
km_vis <- fviz_cluster(list(data = arrest, cluster = km_label),
ellipse.type = "convex",
geom = c("point","text"),
labelsize = 5,
palette = "Dark2") + labs(title = "K-means")
km_vis
# distance between patients
row_distance = dist(arrest, method = "euclidean")
# try different linkage
hc.complete <- hclust(d = row_distance, method = "complete")
plot(hc.complete)
hc_label<-cutree(hc.complete, k = 3)
# hc_label<-cutree(hc.complete, k = 3)
# hc_label<-cutree(hc.average, k = 3)
# hc_label<-cutree(hc.single, k = 3)
# hc_label<-cutree(hc.centroid, k = 3)
hc_label
table(hc_label,km_label)
library(mclust) # Adjusted Rand Index
adjustedRandIndex(hc_label, km_label)
fviz_dend(hc.complete,
k = 3,
cex = 0.3,
palette = "jco",
color_labels_by_k = TRUE,
rect = TRUE,
rect_fill = TRUE,
rect_border = "jco",
labels_track_height = 3.5)
state_pairs <- expand.grid(names(hc_label),names(hc_label))
state_pairs <- tibble(state_pairs[-which(state_pairs[,1]==state_pairs[,2]),]) %>%
rename(state1 = Var1, state2 = Var2)
clusts <- tibble(state1 = names(hc_label), hc = hc_label, km = km$cluster)
full <- clusts %>%
full_join(state_pairs, by = 'state1') %>%
left_join(clusts %>% rename(state2 = state1), by = c('state2'))
full_eval <- full %>%
mutate(together_idx = (hc.x==km.x & hc.y==km.y),
separate_idx = (hc.x!=km.x & hc.y!=km.y),
discord_idx = (!(together_idx | separate_idx)))
rand_idx <- (sum(full_eval$together_idx) + sum(full_eval$separate_idx)) / nrow(full_eval)
rand_idx
arrest_scaled <- arrest %>%
mutate(across(everything(), scale))
# distance between patients
row_distance_scaled = dist(arrest_scaled, method = "euclidean")
hc.complete_scaled <- hclust(d = row_distance_scaled, method = "complete")
plot(hc.complete_scaled)
hc_label<-cutree(hc.complete, k = 3)
hc_label_scaled<-cutree(hc.complete_scaled, k = 3)
table(hc_label, hc_label_scaled)
?hclust
# distance between patients
row_dissim_scaled = as.dist(1 - cor(arrest_scaled))
hc.dissim_scaled <- hclust(d = row_distance_scaled, method = "complete")
table(hc)
# distance between patients
row_dissim_scaled = as.dist(1 - cor(arrest_scaled))
hc.dissim_scaled <- hclust(d = row_distance_scaled, method = "complete")
hc_label_dissim<-cutree(hc.dissim_scaled, k = 3)
table(hc_label_scaled,hc_label_dissim)
# plot(hc.complete_scaled)
# distance between patients
row_dissim_scaled = as.dist(1 - cor(arrest_scaled))
hc.dissim_scaled <- hclust(d = row_dissim_scaled, method = "complete")
hc_label_dissim<-cutree(hc.dissim_scaled, k = 3)
table(hc_label_scaled,hc_label_dissim)
# distance between patients
row_dissim_scaled = as.dist(1 - cor(arrest_scaled))
hc.dissim_scaled <- hclust(d = row_dissim_scaled, method = "complete")
hc_label_dissim<-cutree(hc.dissim_scaled, k = 3)
table(hc_label_scaled,hc_label_dissim)
plot(hc.dissim_scaled)
arrest_scaled
# distance between patients
row_dissim_scaled = as.dist(1 - cor(t(arrest_scaled)))
hc.dissim_scaled <- hclust(d = row_dissim_scaled, method = "complete")
hc_label_dissim<-cutree(hc.dissim_scaled, k = 3)
plot(hc.dissim_scaled)
# plot(hc.complete_scaled)
# distance between patients
row_dissim_scaled = as.dist(1 - cor(t(arrest_scaled)))
hc.dissim_scaled <- hclust(d = row_dissim_scaled, method = "complete")
hc_label_dissim<-cutree(hc.dissim_scaled, k = 3)
table(hc_label_scaled, hc_label_dissim)
# plot(hc.complete_scaled)
row_dissim_scaled
row_dissim_scaled
t(arrest_scaled)
cor(t(arrest_scaled))
row_distance_scaled
row_distance_scaled
cor(t(arrest_scaled))
# distance between patients
row_dissim_scaled = as.dist(1 - cor(t(arrest_scaled)))
hc.dissim_scaled <- hclust(d = row_dissim_scaled, method = "complete")
hc_label_dissim<-cutree(hc.dissim_scaled, k = 3)
table(hc_label_scaled, hc_label_dissim)
plot(as.vector(row_dissim_scaled), as.vector(row_distance_scaled))
# plot(hc.complete_scaled)
row_dissim_scaled
arrest
length(arrest)
nrow(arrest)
# distance between patients
row_dissim_scaled = as.dist(1 - cor(t(arrest_scaled)))
hc.dissim_scaled <- hclust(d = row_dissim_scaled, method = "complete")
hc_label_dissim<-cutree(hc.dissim_scaled, k = 3)
table(hc_label_scaled, hc_label_dissim)
plot(2 - as.vector(row_dissim_scaled)*2, as.vector(row_distance_scaled)^2 / (length(as.vector(row_distance_scaled)) - 1))
# plot(hc.complete_scaled)
row_dissim_scaled %>% summary
# distance between patients
row_dissim_scaled = as.dist(1 - cor(t(arrest_scaled)))
hc.dissim_scaled <- hclust(d = row_dissim_scaled, method = "complete")
hc_label_dissim<-cutree(hc.dissim_scaled, k = 3)
table(hc_label_scaled, hc_label_dissim)
plot(2 - as.vector(row_dissim_scaled)*2, as.vector(row_distance_scaled)^2 / (length(as.vector(row_distance_scaled)) - 1))
# plot(hc.complete_scaled)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
q2 <- tibble(x1 = c(1,1,0,5,6,4), x2 = c(4,3,4,1,2,0))
q2 %>% ggplot(aes(x = x1, y = x2)) + geom_point()
q2$initial_cluster <- sample(1:2, size = nrow(q2), replace = T, prob = c(.5,.5))
q2$cluster <- q2$initial_cluster
while(TRUE) {
means <- q2 %>% group_by(cluster) %>% summarise(mean1 = mean(x1), mean2 = mean(x2))
for (i in 1:nrow(q2)) {
row <- q2[i, c('x1', 'x2')]
distances <- (means$mean1 - row$x1)^2 + (means$mean2 - row$x2)^2
q2$cluster[i] <- which.min(distances)
}
new_means <- q2 %>% group_by(cluster) %>% summarise(mean1 = mean(x1), mean2 = mean(x2))
if (all(means$mean1 == new_means$mean1) && all(means$mean2 == new_means$mean2)) {
break
}
}
q2
centroids <- q2 %>% group_by(cluster) %>% summarise(x1centroids = mean(x1), x2centroids = mean(x2))
q2 %>% ggplot(aes(x = x1, y = x2, shape = factor(cluster), color = factor(cluster), size = 10)) + geom_point() + geom_point(data = centroids, aes(x=x1centroids,y=x2centroids),shape = 'square', size = 5,color='green',inherit.aes=F, alpha = .5)
library(ISLR)
arrest <- USArrests
pca <- prcomp(arrest, center = TRUE, scale. = TRUE)
# matrix of variable loadings
# head(pca$rotation)
dim(pca$rotation)
# PCA demension 1
pca1 <- pca$x[,1]
# PCA demension 2
pca2 <- pca$x[,2]
pctbl <- tibble(pc1 = pca1, pc2 = pca2, state = rownames(arrest))
pctbl %>% ggplot(aes(x = pc1, y = pc2, label = state)) + geom_text()
library(factoextra)
fviz_eig(pca, addlabels = TRUE)
fviz_pca_ind(pca,
label = "none",
addEllipses = TRUE)
# within-cluster sum of squares
WCSS<-rep(0,5)
# choose k:
for(k in 1:6){
# Perform k-means clustering on a data matrix.
res<-kmeans(x = arrest, centers = k, nstart = 100)
# Total within-cluster sum of squares
WCSS[k]<-res$tot.withinss
}
#plot WCSS vs different K values
plot(1:6, WCSS,
type="o", col="black",
xlab="K", ylab="WCSS")
title("WCSS for three-clusters data")
points(3, WCSS[3], col="red",cex=2,pch=20)
library(NbClust)
# We can use NbClust package to calculate the four indices
# CH index
CH <- NbClust(data=arrest, min.nc = 2, max.nc = 6,
method="kmeans", index="ch")
plot(2:6, CH$All.index, type="o",
xlab="number of clusters", ylab="CH index",
"cex.lab"=1.5, cex=2.5)
CH$Best.nc[1]
# CH$Best.partition  #we can also get Partition that
#### corresponds to the best number of clusters
# Hartigan index
H <- NbClust(data=arrest, min.nc = 2, max.nc = 6,
method="kmeans", index="hartigan")
plot(2:6, H$All.index, type="o",
xlab="number of clusters",ylab="Hartigan index",
"cex.lab"=1.5, cex=2.5)
abline(h=10,lty=2,lwd=3) # stop when H(k) < 10
H$Best.nc[1]
# KL index
KL <- NbClust(data=arrest, min.nc = 2, max.nc = 6,
method="kmeans",index="kl")
plot(2:6, KL$All.index, type="o",
xlab="number of clusters",ylab="KL index",
"cex.lab"=1.5, cex=2.5)
KL$Best.nc[1]
# Silhouette index
Sil <- NbClust(data=arrest, min.nc = 2, max.nc = 6,
method="kmeans", index="silhouette")
plot(2:6, Sil$All.index, type="o",
xlab="number of clusters",ylab="Silhouette index",
"cex.lab"=1.5, cex=2.5)
Sil$Best.nc[1]
library(cluster)
gapst <- clusGap(arrest, FUN = kmeans, nstart = 100,
K.max = 6, B = 50,
spaceH0 ="scaledPCA")
plot(gapst, xlab = "number of cluster k", main = "Gap statistics")
gaprs <- with(gapst,
maxSE(Tab[,"gap"],Tab[,"SE.sim"]))
gaprs
# gaprs <- maxSE(gapst$Tab[,"gap"],gapst$Tab[,"SE.sim"])
# print(gaprs, method = "firstmax")
# Observations are represented by points in the plot, using principal components
km <- kmeans(arrest, centers = 3, nstart=10)
km_label <- km$cluster
km_vis <- fviz_cluster(list(data = arrest, cluster = km_label),
ellipse.type = "convex",
geom = c("point","text"),
labelsize = 5,
palette = "Dark2") + labs(title = "K-means")
km_vis
# distance between patients
row_distance = dist(arrest, method = "euclidean")
# try different linkage
hc.complete <- hclust(d = row_distance, method = "complete")
plot(hc.complete)
hc_label<-cutree(hc.complete, k = 3)
# hc_label<-cutree(hc.complete, k = 3)
# hc_label<-cutree(hc.average, k = 3)
# hc_label<-cutree(hc.single, k = 3)
# hc_label<-cutree(hc.centroid, k = 3)
hc_label
fviz_dend(hc.complete,
k = 3,
cex = 0.3,
palette = "jco",
color_labels_by_k = TRUE,
rect = TRUE,
rect_fill = TRUE,
rect_border = "jco",
labels_track_height = 3.5)
table(hc_label,km_label)
library(mclust) # Adjusted Rand Index
adjustedRandIndex(hc_label, km_label)
state_pairs <- expand.grid(names(hc_label),names(hc_label))
state_pairs <- tibble(state_pairs[-which(state_pairs[,1]==state_pairs[,2]),]) %>%
rename(state1 = Var1, state2 = Var2)
clusts <- tibble(state1 = names(hc_label), hc = hc_label, km = km$cluster)
full <- clusts %>%
full_join(state_pairs, by = 'state1') %>%
left_join(clusts %>% rename(state2 = state1), by = c('state2'))
full_eval <- full %>%
mutate(together_idx = (hc.x==km.x & hc.y==km.y),
separate_idx = (hc.x!=km.x & hc.y!=km.y),
discord_idx = (!(together_idx | separate_idx)))
rand_idx <- (sum(full_eval$together_idx) + sum(full_eval$separate_idx)) / nrow(full_eval)
rand_idx
arrest_scaled <- arrest %>%
mutate(across(everything(), scale))
# distance between patients
row_distance_scaled = dist(arrest_scaled, method = "euclidean")
hc.complete_scaled <- hclust(d = row_distance_scaled, method = "complete")
plot(hc.complete_scaled)
hc_label<-cutree(hc.complete, k = 3)
hc_label_scaled<-cutree(hc.complete_scaled, k = 3)
table(hc_label, hc_label_scaled)
# distance between patients
row_dissim_scaled = as.dist(1 - cor(t(arrest_scaled)))
hc.dissim_scaled <- hclust(d = row_dissim_scaled, method = "complete")
hc_label_dissim<-cutree(hc.dissim_scaled, k = 3)
table(hc_label_scaled, hc_label_dissim)
plot(2 - as.vector(row_dissim_scaled)*2, as.vector(row_distance_scaled)^2 / (length(as.vector(row_distance_scaled)) - 1))
# plot(hc.complete_scaled)
